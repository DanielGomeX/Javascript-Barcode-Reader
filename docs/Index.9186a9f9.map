{"version":3,"sources":["..\\src\\ean-13\\index.js","..\\src\\code-39\\index.js","..\\src\\code-93\\index.js","..\\src\\Index.js"],"names":["UPC_SET","module","exports","code","bar","lines","i","length","group","slice","digits","Math","round","join","reverse","indexOf","BAR_SET","GROUP_SET","CHAR_SET","push","segment","barThreshold","reduce","pre","item","noob","map","barSeg","filter","index","whiteSeg","parseInt","substring","DecoderEAN13","require","DecoderCode39","DecoderCode93","BARCODE_DECODERS","barcodeDecoder","imageSource","options","ImageData","document","getElementById","elementType","tagName","canvas","createElement","width","naturalWidth","height","naturalHeight","ctx","getContext","drawImage","getImageData","data","Error","numLines","spoints","slineStep","start","floor","end","pxLine","sum","min","max","row","col","g","s","undefined","pivot","bmp","matches","curr","count","barcode","javascriptBarcodeReader"],"mappings":"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","file":"Index.9186a9f9.map","sourceRoot":"..\\docs-src","sourcesContent":["const UPC_SET = {\r\n  '3211': '0',\r\n  '2221': '1',\r\n  '2122': '2',\r\n  '1411': '3',\r\n  '1132': '4',\r\n  '1231': '5',\r\n  '1114': '6',\r\n  '1312': '7',\r\n  '1213': '8',\r\n  '3112': '9',\r\n}\r\n\r\nmodule.exports = lines => {\r\n  let code = ''\r\n  // start indicator/reference lines\r\n  const bar = ~~((lines[1] + lines[2] + lines[3]) / 3) //eslint-disable-line\r\n\r\n  for (let i = 1; i < lines.length; i += 1) {\r\n    let group\r\n\r\n    if (code.length < 6) {\r\n      group = lines.slice(i * 4, i * 4 + 4)\r\n    } else {\r\n      group = lines.slice(i * 4 + 5, i * 4 + 9)\r\n    }\r\n\r\n    const digits = [\r\n      Math.round(group[0] / bar),\r\n      Math.round(group[1] / bar),\r\n      Math.round(group[2] / bar),\r\n      Math.round(group[3] / bar),\r\n    ]\r\n\r\n    code +=\r\n      UPC_SET[digits.join('')] || UPC_SET[digits.reverse().join('')] || 'X'\r\n\r\n    if (code.length === 12) {\r\n      return code\r\n      // eslint-disable-next-line\r\n      break\r\n    }\r\n  }\r\n  if (code.indexOf('X') === -1) {\r\n    return code || false\r\n  }\r\n\r\n  return false\r\n}\r\n","const BAR_SET = {\r\n  '10001': '1',\r\n  '01001': '2',\r\n  '11000': '3',\r\n  '00101': '4',\r\n  '10100': '5',\r\n  '01100': '6',\r\n  '00011': '7',\r\n  '10010': '8',\r\n  '01010': '9',\r\n  '00110': '10',\r\n}\r\n\r\nconst GROUP_SET = {\r\n  '01000': '0',\r\n  '00100': '10',\r\n  '00010': '20',\r\n  '10000': '30',\r\n}\r\n\r\nconst CHAR_SET = [\r\n  '1',\r\n  '2',\r\n  '3',\r\n  '4',\r\n  '5',\r\n  '6',\r\n  '7',\r\n  '8',\r\n  '9',\r\n  '0',\r\n  'A',\r\n  'B',\r\n  'C',\r\n  'D',\r\n  'E',\r\n  'F',\r\n  'G',\r\n  'H',\r\n  'I',\r\n  'J',\r\n  'K',\r\n  'L',\r\n  'M',\r\n  'N',\r\n  'O',\r\n  'P',\r\n  'Q',\r\n  'R',\r\n  'S',\r\n  'T',\r\n  'U',\r\n  'V',\r\n  'W',\r\n  'X',\r\n  'Y',\r\n  'Z',\r\n  '-',\r\n  '.',\r\n  '␣',\r\n  '*',\r\n]\r\n\r\nmodule.exports = lines => {\r\n  // manualy push last white space\r\n  lines.push(0)\r\n  let code = ''\r\n\r\n  for (let i = 1; i < lines.length; i += 10) {\r\n    const segment = lines.slice(i, i + 10)\r\n\r\n    const barThreshold = Math.round(\r\n      segment.reduce((pre, item) => pre + item, 0) / segment.length\r\n    )\r\n\r\n    const noob = segment.map(item => (item > barThreshold ? 1 : 0))\r\n    const barSeg = noob.filter((item, index) => index % 2 === 0).join('')\r\n    const whiteSeg = noob.filter((item, index) => index % 2 !== 0).join('')\r\n\r\n    code +=\r\n      CHAR_SET[\r\n        parseInt(BAR_SET[barSeg], 10) - 1 + parseInt(GROUP_SET[whiteSeg], 10)\r\n      ]\r\n  }\r\n\r\n  return code.substring(1, code.length - 1)\r\n}\r\n","const BAR_SET = {\r\n  '10001': '1',\r\n  '01001': '2',\r\n  '11000': '3',\r\n  '00101': '4',\r\n  '10100': '5',\r\n  '01100': '6',\r\n  '00011': '7',\r\n  '10010': '8',\r\n  '01010': '9',\r\n  '00110': '10',\r\n}\r\n\r\nconst GROUP_SET = {\r\n  '01000': '0',\r\n  '00100': '10',\r\n  '00010': '20',\r\n  '10000': '30',\r\n}\r\n\r\nconst CHAR_SET = [\r\n  '1',\r\n  '2',\r\n  '3',\r\n  '4',\r\n  '5',\r\n  '6',\r\n  '7',\r\n  '8',\r\n  '9',\r\n  '0',\r\n  'A',\r\n  'B',\r\n  'C',\r\n  'D',\r\n  'E',\r\n  'F',\r\n  'G',\r\n  'H',\r\n  'I',\r\n  'J',\r\n  'K',\r\n  'L',\r\n  'M',\r\n  'N',\r\n  'O',\r\n  'P',\r\n  'Q',\r\n  'R',\r\n  'S',\r\n  'T',\r\n  'U',\r\n  'V',\r\n  'W',\r\n  'X',\r\n  'Y',\r\n  'Z',\r\n  '-',\r\n  '.',\r\n  '␣',\r\n  '*',\r\n]\r\n\r\nmodule.exports = lines => {\r\n  // manualy push last white space\r\n  lines.push(3)\r\n  let code = ''\r\n\r\n  for (let i = 1; i < lines.length; i += 10) {\r\n    const segment = lines.slice(i, i + 10)\r\n\r\n    const barThreshold = Math.round(\r\n      segment.reduce((pre, item) => pre + item, 0) / segment.length\r\n    )\r\n\r\n    const noob = segment.map(item => (item > barThreshold ? 1 : 0))\r\n    const barSeg = noob.filter((item, index) => index % 2 === 0).join('')\r\n    const whiteSeg = noob.filter((item, index) => index % 2 !== 0).join('')\r\n\r\n    code +=\r\n      CHAR_SET[\r\n        parseInt(BAR_SET[barSeg], 10) - 1 + parseInt(GROUP_SET[whiteSeg], 10)\r\n      ]\r\n  }\r\n\r\n  return code.substring(1, code.length - 1)\r\n}\r\n","const DecoderEAN13 = require('./ean-13')\r\nconst DecoderCode39 = require('./code-39')\r\nconst DecoderCode93 = require('./code-93')\r\n\r\nconst BARCODE_DECODERS = {\r\n  'code-93': DecoderCode93,\r\n  'code-39': DecoderCode39,\r\n  'ean-13': DecoderEAN13,\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} image Image element || Canvas || ImageData\r\n * @param {Object} options\r\n */\r\nconst barcodeDecoder = (imageSource, options) => {\r\n  let ImageData\r\n\r\n  if (typeof imageSource === 'string')\r\n    imageSource = document.getElementById(imageSource)\r\n\r\n  let elementType = imageSource.tagName\r\n  if (elementType === 'IMG') {\r\n    const canvas = document.createElement('canvas')\r\n    canvas.width = imageSource.naturalWidth\r\n    canvas.height = imageSource.naturalHeight\r\n    const ctx = canvas.getContext('2d')\r\n\r\n    ctx.drawImage(imageSource, 0, 0)\r\n\r\n    ImageData = ctx.getImageData(\r\n      0,\r\n      0,\r\n      imageSource.naturalWidth,\r\n      imageSource.naturalHeight\r\n    )\r\n  } else if (elementType === 'CANVAS') {\r\n    ImageData = imageSource\r\n      .getContext('2d')\r\n      .getImageData(0, 0, imageSource.naturalWidth, imageSource.naturalHeight)\r\n  } else if (imageSource.data) {\r\n    ImageData = imageSource\r\n  } else {\r\n    throw new Error('Invalid image source specified!')\r\n  }\r\n\r\n  const { data, width, height } = ImageData\r\n  imageSource = null\r\n  ImageData = null\r\n\r\n  // check points for barcode location\r\n  const spoints = [1, 9, 2, 8, 3, 7, 4, 6, 5]\r\n  let numLines = spoints.length\r\n  const slineStep = height / (numLines + 1)\r\n\r\n  // eslint-disable-next-line\r\n  while ((numLines -= 1)) {\r\n    // create section of height 2\r\n    const start = 4 * width * Math.floor(slineStep * spoints[numLines])\r\n    const end =\r\n      4 * width * Math.floor(slineStep * spoints[numLines]) + 2 * 4 * width\r\n    const pxLine = data.slice(start, end)\r\n    const sum = []\r\n    let min = 0\r\n    let max = 0\r\n\r\n    // grey scale section and sum of columns pixels in section\r\n    for (let row = 0; row < 2; row += 1) {\r\n      for (let col = 0; col < width; col += 1) {\r\n        const i = (row * width + col) * 4\r\n        const g = (pxLine[i] * 3 + pxLine[i + 1] * 4 + pxLine[i + 2] * 2) / 9\r\n        const s = sum[col]\r\n\r\n        pxLine[i] = g\r\n        pxLine[i + 1] = g\r\n        pxLine[i + 2] = g\r\n\r\n        sum[col] = g + (s === undefined ? 0 : s)\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < width; i += 1) {\r\n      sum[i] /= 2\r\n      const s = sum[i]\r\n\r\n      if (s < min) {\r\n        min = s\r\n      }\r\n      if (s > max) {\r\n        max = s\r\n      }\r\n    }\r\n\r\n    // matches columns in two rows\r\n    const pivot = min + (max - min) / 2\r\n    const bmp = []\r\n\r\n    for (let col = 0; col < width; col += 1) {\r\n      let matches = 0\r\n      for (let row = 0; row < 2; row += 1) {\r\n        if (pxLine[(row * width + col) * 4] > pivot) {\r\n          matches += 1\r\n        }\r\n      }\r\n      bmp.push(matches > 1)\r\n    }\r\n\r\n    // matches width of barcode lines\r\n    let curr = bmp[0]\r\n    let count = 1\r\n    const lines = []\r\n\r\n    for (let col = 0; col < width; col += 1) {\r\n      if (bmp[col] === curr) {\r\n        count += 1\r\n      } else {\r\n        lines.push(count)\r\n        count = 1\r\n        curr = bmp[col]\r\n      }\r\n    }\r\n\r\n    // TODO:  If not found in first step, continue searching until while loop\r\n\r\n    // Run the decoder\r\n    return BARCODE_DECODERS[options.barcode](lines)\r\n  }\r\n  return null\r\n}\r\n\r\nif (module && module.exports) {\r\n  module.exports = barcodeDecoder\r\n} else {\r\n  root.javascriptBarcodeReader = barcodeDecoder\r\n}\r\n"]}